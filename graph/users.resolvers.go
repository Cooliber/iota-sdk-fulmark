package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"net/http"

	model "github.com/iota-agency/iota-erp/graph/gqlmodels"
	"github.com/iota-agency/iota-erp/internal/domain/user"
	"github.com/iota-agency/iota-erp/sdk/composables"
	"github.com/iota-agency/iota-erp/sdk/mapper"
	"github.com/iota-agency/iota-erp/sdk/utils/env"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUser) (*model.User, error) {
	u := &user.User{}
	if err := mapper.LenientMapping(&input, u); err != nil {
		return nil, err
	}
	if input.Password != nil {
		if err := u.SetPassword(*input.Password); err != nil {
			return nil, err
		}
	}
	if err := r.app.UserService.Create(ctx, u); err != nil {
		return nil, err
	}
	return u.ToGraph(), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id int64, input model.UpdateUser) (*model.User, error) {
	entity, err := r.app.UserService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if err := mapper.LenientMapping(&input, entity); err != nil {
		return nil, err
	}
	if input.Password != nil {
		if err := entity.SetPassword(*input.Password); err != nil {
			return nil, err
		}
	}
	if err := r.app.UserService.Update(ctx, entity); err != nil {
		return nil, err
	}
	return entity.ToGraph(), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id int64) (bool, error) {
	if err := r.app.UserService.Delete(ctx, id); err != nil {
		return false, err
	}
	return true, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int64) (*model.User, error) {
	entity, err := r.app.UserService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return entity.ToGraph(), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, offset int, limit int, sortBy []string) (*model.PaginatedUsers, error) {
	entities, err := r.app.UserService.GetPaginated(ctx, limit, offset, sortBy)
	if err != nil {
		return nil, err
	}
	result := make([]*model.User, len(entities))
	for i, entity := range entities {
		result[i] = entity.ToGraph()
	}
	total, err := r.app.UserService.Count(ctx)
	if err != nil {
		return nil, err
	}
	return &model.PaginatedUsers{
		Data:  result,
		Total: total,
	}, nil
}

// UserCreated is the resolver for the userCreated field.
func (r *subscriptionResolver) UserCreated(ctx context.Context) (<-chan *model.User, error) {
	ch := make(chan *model.User)
	r.app.EventPublisher.Subscribe("user.created", func(data interface{}) {
		if entity, ok := data.(*user.User); ok {
			ch <- entity.ToGraph()
		}
	})
	return ch, nil
}

// UserUpdated is the resolver for the userUpdated field.
func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *model.User, error) {
	ch := make(chan *model.User)
	r.app.EventPublisher.Subscribe("user.updated", func(data interface{}) {
		if entity, ok := data.(*user.User); ok {
			ch <- entity.ToGraph()
		}
	})
	return ch, nil
}

// UserDeleted is the resolver for the userDeleted field.
func (r *subscriptionResolver) UserDeleted(ctx context.Context) (<-chan int64, error) {
	ch := make(chan int64)
	r.app.EventPublisher.Subscribe("user.deleted", func(data interface{}) {
		if id, ok := data.(int64); ok {
			ch <- id
		}
	})
	return ch, nil
}

// Avatar is the resolver for the avatar field.
func (r *userResolver) Avatar(ctx context.Context, obj *model.User) (*model.Upload, error) {
	if obj.AvatarID == nil {
		return nil, nil
	}
	upload, err := r.app.UploadService.GetUploadByID(ctx, *obj.AvatarID)
	if err != nil {
		return nil, err
	}
	return upload.ToGraph(), nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) Authenticate(ctx context.Context, email string, password string) (*model.Session, error) {
	writer, ok := composables.UseWriter(ctx)
	if !ok {
		return nil, fmt.Errorf("request params not found")
	}
	_, session, err := r.app.AuthService.Authenticate(ctx, email, password)
	if err != nil {
		return nil, err
	}
	cookie := &http.Cookie{
		Name:     "token",
		Value:    session.Token,
		Expires:  session.ExpiresAt,
		HttpOnly: false,
		SameSite: http.SameSiteNoneMode,
		Secure:   false,
		Domain:   env.GetEnv("DOMAIN", "localhost"),
	}
	http.SetCookie(writer, cookie)
	return session.ToGraph(), nil
}
